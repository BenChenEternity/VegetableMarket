# README

# 作者

此项目由本人独立开发

**21 网络工程 陈嘉杰 202130440194 **

## 项目

### Github地址

https://github.com/BenChenEternity/VegetableMarket

### 代码文件说明

- spring-boot-3 目录下是后端Spring Boot项目的源代码
- vue-3.0 是前端vue开发的源文件，内的dist文件夹是打包后的静态网页
- vege.sql 是数据库迁移时的数据库文件

## 部署

### 部署地址

https://ajie.cool/vegetable

### 服务器

Microsoft Azure Windows Server 2022

### 数据库

**My SQL 8.0**

### 后端

**Spring Boot 3**  基于  **JDK-17**

- 集成 **MyBatis** 操作**My SQL**
- 集成 **Jedis** 操作 **Redis**
- 部署于内置 **Tomcat**

### 前端

**Vue框架**

- 集成 **Element UI **美化界面
- 使用 **Axios** 与后端对接
- 打包并部署于 **Tomcat 10.1.16 **

## 安全性

### HTTPS

本项目部署使用了**HTTPS**（基于TLS/SSL），提供数据传输加密，身份验证，完整性校验。

证书由可信机构 **亚洲诚信 TrustAsia** 颁发，由 **腾讯云** 代理颁发，绑定域名 **ajie.cool** 。

**证书ID：AN758vo7**

**证书过期时间：2024-11-22 07:59:59**

### 服务器安全

服务器使用 **微软 Microsoft Azure** 的 **Windows Server 2022** ，安全性高，若受到攻击（尤其是DDOS）上级能够有效防御。

**微软服务器预计于 2024-1-20 过期**

### 流量安全

#### 访问控制

目前服务器只对入站流量开放了以下几个端口：

- 80  HTTP （重定向到443）
- 443  HTTPS
- 3389  RDP

关闭其他一切端口，有效防止攻击。对于其他端口（如来自公网Redis 6379， MySQL 3306的流量全部拒绝）

这个访问控制策略于微软硬件防火墙生效。

#### Windows Firewall

windows服务器软件防火墙同样配置相同的访问控制列表，控制访问端口流量。

### 反向代理隐藏内部细节

使用Nginx反向代理流量，大致规则如下：

- 80端口的流量全部重定向至443端口，使用HTTPS协议
- 443端口并且前缀不与后端API匹配的流量转发至部署于本地 **Tomcat** 的前端端口
- 443端口并且前缀于后端API匹配的两两转发至 **Java** 后端应用程序端口 (也是基于 **Tomcat**)

这样就有效避免其他端口暴露于公网，公网与后端、数据库、Redis通信段流量全部经过 **Nginx反向代理** ，屏蔽服务器内部细节

### 应用层安全

#### Token认证

类似于会话技术的CSRF token，我自己定义了一个UUID token，每当用户登录成功时就返回该UUID给用户，并且在Redis中存储该UUID token一定时间。每次用户发起关键请求时都需要token认证。当这个token处于有效期时，认为与用户建立了一个虚拟的会话（Session）。

对于每个用户，这个token是唯一的。当token有效时，用户再次登录，那么新的token会覆盖前一次的token。

如果token认证失败（session过期，伪造token，其他人登录此账户覆盖了原token等等原因），那么后端不会返回请求的数据，而是401 （Unauthorized）或者404（Not Found）。

**这个token认证是我自己使用UUID+Redis实现的，没有调用相关的token包。**

#### 前端路由守卫

前端使用vue框架布置路由守卫，在每次路由跳转时，进行token认证，如果认证失败，前端会自动重定向到登录页面。

#### 前端条件渲染

根据不同的用户等级渲染不同的界面。比如只有Owner才有管理用户的界面，其他更低等级的渲染不出来。

#### 密码加密

在数据库中，密码使用 **SHA-256** 哈希算法加密，验证密码时，先将用户输入的密码进行哈希加密，再与数据库中的加密密码进行比较。数据库的管理者都无法查看用户的密码，即使数据库泄露，也不会导致密码泄露。